\section*{Practical 6: Crosschecking our Generation and Analysis}

Today we will generate data in Python and use both our analysis and MadAnalysis to see if we get the same cross section and angular distribution. We will also try generating some data in MadGraph, and run both analyses to see if they match.

Firstly, lets install MadAnalysis. To ensure everything runs smoothly, lets create a new virtual environment. First, we navigate to the \codeinline{MG5_aMC_v3_5_7} folder and run
\begin{codeenv}
 python3 -m venv venv
 \end{codeenv}
and activative it using
\begin{codeenv}
     source venv/bin/activate
\end{codeenv}
We install the dependancies
\begin{codeenv}
    pip install six
\end{codeenv}

Let's run MadGraph
\begin{codeenv}
    ./bin/mg5_aMC
\end{codeenv}
and run
\begin{codeenv}
    install MadAnalysis5 
\end{codeenv}

\begin{itemize}
    \item \textit{Our first task in order to be able to compare the MadAnalysis with our analysis is to ensure both programs are using the same cuts. This means we should implement the cut based on the value of $\Delta R_{ij}$, rather than $\cos\theta$, in our code in the same way MadGraph does.}
\end{itemize}

We can then run both programs to see if we get the same cross-section. This should hopefully agree. However, this doesn't prove our code to be correct - we may have two compensatory mistakes in our generation and analysis that negate eachother to give us the same answer as MadGraph. To make sure this isn't the case, we can generate data with our code then analyse in MadAnalysis, and generate data with MadGraph and then analyse with our code. If these match, then this is a great sign!

\begin{itemize}
    \item \textit{So, our next task will be to write a function to import data and analyse generated by MadGraph.}
\end{itemize}

Recall that we can obtain a dataset from MadGraph by running
\begin{codeenv}
    generate e+ e- > d d~ g / z
    output quicktest
    launch
\end{codeenv}
This will generate a dataset and compute the cross section. We can then
\begin{codeenv}
    cd quicktest
    cd Events
    cd run_01
    ls
\end{codeenv}
and should see a file \codeinline{unweighted_events.lhe.gz}. This contains the data generated by MadGraph. Inside our \codeinline{run.py}, we should add a new case to \codeinline{__main__} for our analysis of MadGraph files. Already, there is a parser defined, \codeinline{parser_rratio_analyze_events_experiment}. You should create a new experiment file, similar to \codeinline{rratio_differential.py}, where instead of generating phase space points in \codeinline{integrand()}, you import the MadGraph data. Of course, we will need to parse the data in a form that is compatible with our code. To do this, take a look at \codeinline{utils/lhe_parser.py}. Once this is implemented, running our analysis on the MadGraph data should give us a similar result to the data we generated ourself!

\begin{itemize}
    \item \textit{The final task will be to analyse our generated data with MadAnalysis.}
\end{itemize}
Note that in \codeinline{rratio_differential.py} we can see a line of code already
\begin{codeenv}
        event_file = CHEPEventFile("./epem_ddxg.lhe", mode='w')
\end{codeenv}
Note that the \codeinline{integrand()} method takes this as an input argument. We can see in this method that if the phase space point passes our cuts, we already write to the event file. So, after running our code we should already see this file in our directory. There is also code
\begin{codeenv}
        unweighted_event_file = CHEPEventFile("./epem_ddxg.lhe", mode='r')
    unweighted_event_file.unweight("./unweighted_epem_ddxg.lhe")
    unweighted_event_file.close()
\end{codeenv}
and thus we should also see an unweighted version in the directory.
\color{red}MadAnalysis import and analyse data\color{black}

Plotting etc.